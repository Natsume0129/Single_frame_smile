<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Smile / No-Smile Label Tool</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    body { margin: 0; padding: 16px; background: #0b0f14; color: #e8eef6; }
    .wrap { max-width: 1100px; margin: 0 auto; display: grid; gap: 12px; }
    .topbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .card { background: #121a23; border: 1px solid #223044; border-radius: 12px; padding: 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn { cursor: pointer; border: 1px solid #2a3a52; background: #172233; color: #e8eef6; padding: 10px 12px; border-radius: 10px; font-weight: 600; }
    .btn:hover { background: #1c2a40; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: #3d6ea8; }
    .btn.warn { border-color: #a86a3d; }
    .btn.good { border-color: #3da86a; }
    .btn.danger { border-color: #a83d3d; }
    .btn.gray { border-color: #6b7a8f; }
    .muted { color: #9fb3c8; font-size: 13px; }
    .kv { display: grid; grid-template-columns: 120px 1fr; gap: 6px 10px; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #2a3a52; font-size: 12px; }
    .imgbox { display: grid; place-items: center; background: #0b0f14; border: 1px solid #223044; border-radius: 12px; padding: 8px; min-height: 520px; }
    img { max-width: 100%; max-height: 72vh; object-fit: contain; border-radius: 8px; }
    .footer { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
           font-size: 12px; padding: 2px 6px; border: 1px solid #2a3a52; border-bottom-width: 2px;
           border-radius: 6px; background: #0f1620; }
    .spacer { flex: 1; }
    .stat { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .progress { height: 10px; background: #0f1620; border: 1px solid #223044; border-radius: 999px; overflow: hidden; }
    .bar { height: 100%; width: 0%; background: #3d6ea8; }
    .hint { line-height: 1.6; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card topbar">
      <div class="row">
        <label class="btn primary" for="folderInput">Select Folder</label>
        <input id="folderInput" type="file" webkitdirectory multiple accept="image/*" style="display:none" />
        <button id="shuffleBtn" class="btn warn" type="button" disabled>Reshuffle</button>
        <button id="exportBtn" class="btn good" type="button" disabled>Export .dat</button>
        <button id="clearBtn" class="btn danger" type="button" disabled>Reset</button>
      </div>
      <div class="spacer"></div>
      <div class="stat">
        <span class="pill" id="countPill">Not loaded</span>
        <span class="pill" id="donePill">Labeled: 0 | Discarded: 0</span>
      </div>
    </div>

    <div class="card">
      <div class="kv">
        <div class="muted">Current File</div>
        <div id="filePath" style="word-break: break-all;">-</div>

        <div class="muted">Current Value</div>
        <div>
          <span class="pill" id="currentLabelPill">Unlabeled</span>
        </div>

        <div class="muted">Progress</div>
        <div>
          <div class="progress" aria-label="progress">
            <div class="bar" id="progressBar"></div>
          </div>
          <div class="muted" id="progressText" style="margin-top:6px;">-</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="imgbox">
        <img id="preview" alt="preview" />
      </div>
    </div>

    <div class="card footer">
      <div class="row">
        <button class="btn" id="btnSmile" type="button">IsSmiling (1) <span class="kbd">Q</span></button>
        <button class="btn" id="btnNoSmile" type="button">NotSmiling (0) <span class="kbd">P</span></button>
        <button class="btn gray" id="btnDiscard" type="button">Discard <span class="kbd">Space</span></button>
        <button class="btn" id="btnPrev" type="button">Previous <span class="kbd">Backspace</span></button>
        <button class="btn" id="btnNext" type="button">Next <span class="kbd">â†’</span></button>
      </div>

      <div class="muted hint">
        Keys: <span class="kbd">Q</span>=IsSmiling(1), <span class="kbd">P</span>=NotSmiling(0),
        <span class="kbd">Space</span>=Discard, <span class="kbd">Backspace</span>=Previous.
        Auto-next after labeling/discarding.
      </div>
    </div>
  </div>

  <script>
    // ===== Utilities =====
    const isImageFile = (f) => {
      if (f.type && f.type.startsWith("image/")) return true;
      const name = (f.name || "").toLowerCase();
      return /\.(png|jpg|jpeg|webp|gif|bmp|tif|tiff)$/i.test(name);
    };

    // Fisher-Yates shuffle (in-place)
    const shuffleInPlace = (arr) => {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };

    const downloadText = (filename, text) => {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };

    // ===== State =====
    let files = [];               // Array<File>
    let order = [];               // Array<number> indices into files (remaining queue)
    let idx = 0;                  // current position in order
    let labels = new Map();       // key: path string, value: "1" or "0"
    let discarded = new Set();    // key: path string
    let currentObjectUrl = null;  // to revoke when switching images

    // Key = relative path if possible, else filename
    const getPathKey = (file) => file.webkitRelativePath || file.name;

    // IMPORTANT: mapping exactly as corrected:
    // IsSmiling -> 1, NotSmiling -> 0
    const VALUE_SMILE = "1";
    const VALUE_NO_SMILE = "0";

    // ===== Elements =====
    const folderInput = document.getElementById("folderInput");
    const shuffleBtn  = document.getElementById("shuffleBtn");
    const exportBtn   = document.getElementById("exportBtn");
    const clearBtn    = document.getElementById("clearBtn");

    const btnSmile   = document.getElementById("btnSmile");
    const btnNoSmile = document.getElementById("btnNoSmile");
    const btnDiscard = document.getElementById("btnDiscard");
    const btnPrev    = document.getElementById("btnPrev");
    const btnNext    = document.getElementById("btnNext");

    const preview   = document.getElementById("preview");
    const filePath  = document.getElementById("filePath");
    const currentLabelPill = document.getElementById("currentLabelPill");
    const countPill = document.getElementById("countPill");
    const donePill  = document.getElementById("donePill");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");

    // ===== UI updates =====
    const updateTopStats = () => {
      if (!files.length) {
        countPill.textContent = "Not loaded";
        donePill.textContent = "Labeled: 0 | Discarded: 0";
        progressBar.style.width = "0%";
        shuffleBtn.disabled = true;
        exportBtn.disabled = true;
        clearBtn.disabled = true;
        return;
      }

      countPill.textContent = `Loaded: ${files.length} | Remaining: ${order.length}`;
      donePill.textContent = `Labeled: ${labels.size} | Discarded: ${discarded.size}`;

      shuffleBtn.disabled = false;
      exportBtn.disabled = false;
      clearBtn.disabled = false;

      const denom = order.length || 0;
      const p = denom ? Math.round((labels.size / denom) * 100) : 100;
      progressBar.style.width = `${p}%`;
    };

    const setCurrentLabelPill = (value) => {
      if (!value) {
        currentLabelPill.textContent = "Unlabeled";
        currentLabelPill.style.borderColor = "#2a3a52";
        return;
      }
      const txt = value === VALUE_SMILE ? "IsSmiling (1)" : "NotSmiling (0)";
      currentLabelPill.textContent = txt;
      currentLabelPill.style.borderColor = (value === VALUE_SMILE) ? "#3da86a" : "#a83d3d";
    };

    const renderCurrent = () => {
      if (!files.length || !order.length) {
        filePath.textContent = order.length === 0 && files.length ? "(No remaining images)" : "-";
        progressText.textContent = order.length === 0 && files.length ? "Done" : "-";
        preview.removeAttribute("src");
        setCurrentLabelPill(null);
        updateTopStats();
        return;
      }

      if (idx < 0) idx = 0;
      if (idx >= order.length) idx = order.length - 1;

      const file = files[order[idx]];
      const key = getPathKey(file);

      filePath.textContent = key;
      progressText.textContent = `Image ${idx + 1} / ${order.length} (remaining)`;

      setCurrentLabelPill(labels.get(key) || null);

      if (currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);
      currentObjectUrl = URL.createObjectURL(file);
      preview.src = currentObjectUrl;

      updateTopStats();
    };

    // ===== Actions =====
    const goNext = () => {
      if (!files.length || !order.length) return;
      if (idx < order.length - 1) idx++;
      renderCurrent();
    };

    const goPrev = () => {
      if (!files.length || !order.length) return;
      if (idx > 0) idx--;
      renderCurrent();
    };

    const applyValue = (value) => {
      if (!files.length || !order.length) return;
      const file = files[order[idx]];
      const key = getPathKey(file);

      discarded.delete(key);
      labels.set(key, value);

      renderCurrent();

      if (idx < order.length - 1) {
        idx++;
        renderCurrent();
      }
    };

    const discardCurrent = () => {
      if (!files.length || !order.length) return;

      const currentIndexInFiles = order[idx];
      const file = files[currentIndexInFiles];
      const key = getPathKey(file);

      discarded.add(key);
      labels.delete(key);

      // Remove from remaining queue
      order.splice(idx, 1);

      if (idx >= order.length) idx = order.length - 1;
      renderCurrent();
    };

    const exportDat = () => {
      if (!files.length) return;

      // Export ONLY remaining (non-discarded) images.
      // One line per image: "<path> <value>"
      // If unlabeled, value part is empty.
      const lines = [];
      for (const i of order) {
        const f = files[i];
        const key = getPathKey(f);
        const value = labels.get(key) || "";
        lines.push(`${key} ${value}`.trimEnd());
      }
      downloadText("labels.dat", lines.join("\n"));
    };

    const resetAll = () => {
      labels = new Map();
      discarded = new Set();
      order = files.map((_, i) => i);
      shuffleInPlace(order);
      idx = 0;
      renderCurrent();
    };

    const reshuffle = () => {
      if (!files.length) return;
      order = shuffleInPlace(order);
      idx = 0;
      renderCurrent();
    };

    // ===== Events =====
    folderInput.addEventListener("change", (e) => {
      const picked = Array.from(e.target.files || []).filter(isImageFile);

      files = picked;
      order = files.map((_, i) => i);
      shuffleInPlace(order);

      idx = 0;
      labels = new Map();
      discarded = new Set();
      renderCurrent();
    });

    shuffleBtn.addEventListener("click", reshuffle);
    exportBtn.addEventListener("click", exportDat);
    clearBtn.addEventListener("click", resetAll);

    btnSmile.addEventListener("click", () => applyValue(VALUE_SMILE));
    btnNoSmile.addEventListener("click", () => applyValue(VALUE_NO_SMILE));
    btnDiscard.addEventListener("click", discardCurrent);
    btnPrev.addEventListener("click", goPrev);
    btnNext.addEventListener("click", goNext);

    // Keyboard mapping
    window.addEventListener("keydown", (e) => {
      const k = e.key;

      // Backspace: previous (prevent browser back navigation)
      if (k === "Backspace") {
        e.preventDefault();
        goPrev();
        return;
      }

      // Space: discard (prevent scroll)
      if (k === " ") {
        e.preventDefault();
        discardCurrent();
        return;
      }

      // Q: IsSmiling -> 1
      if (k === "q" || k === "Q") {
        e.preventDefault();
        applyValue(VALUE_SMILE);
        return;
      }

      // P: NotSmiling -> 0
      if (k === "p" || k === "P") {
        e.preventDefault();
        applyValue(VALUE_NO_SMILE);
        return;
      }

      // Optional: ArrowRight -> Next (manual skip without labeling)
      if (k === "ArrowRight") {
        e.preventDefault();
        goNext();
        return;
      }
    });

    // Initial UI
    renderCurrent();
  </script>
</body>
</html>
